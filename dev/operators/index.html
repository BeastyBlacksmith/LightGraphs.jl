<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Operators · LightGraphs</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LightGraphs</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><a class="tocitem" href="../graphtypes/">Choosing A Graph Type</a></li><li><a class="tocitem" href="../types/">LightGraphs Types</a></li><li><a class="tocitem" href="../basicproperties/">Accessing Properties</a></li><li><a class="tocitem" href="../generators/">Making and Modifying Graphs</a></li><li><a class="tocitem" href="../persistence/">Reading / Writing Graphs</a></li><li class="is-active"><a class="tocitem" href>Operators</a><ul class="internal"><li><a class="tocitem" href="#Full-Docs-1"><span>Full Docs</span></a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting Graphs</a></li><li><a class="tocitem" href="../pathing/">Path and Traversal</a></li><li><a class="tocitem" href="../coloring/">Coloring</a></li><li><a class="tocitem" href="../distance/">Distance</a></li><li><a class="tocitem" href="../centrality/">Centrality Measures</a></li><li><a class="tocitem" href="../linalg/">Linear Algebra</a></li><li><a class="tocitem" href="../matching/">Matching</a></li><li><a class="tocitem" href="../community/">Community Structures</a></li><li><a class="tocitem" href="../degeneracy/">Degeneracy</a></li><li><a class="tocitem" href="../integration/">Integration with other packages</a></li><li><a class="tocitem" href="../experimental/">Experimental Functionality</a></li><li><a class="tocitem" href="../parallel/">Parallel Algorithms</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../developing/">Developer Notes</a></li><li><a class="tocitem" href="../license/">License Information</a></li><li><a class="tocitem" href="../citing/">Citing LightGraphs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Operators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/master/docs/src/operators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Operators-1"><a class="docs-heading-anchor" href="#Operators-1">Operators</a><a class="docs-heading-anchor-permalink" href="#Operators-1" title="Permalink"></a></h1><p><em>LightGraphs.jl</em> implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both <code>SimpleGraph</code> or both <code>SimpleDiGraph</code>).</p><ul><li><a href="#Base.intersect-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>Base.intersect</code></a></li><li><a href="#Base.join-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>Base.join</code></a></li><li><a href="#Base.reverse-Union{Tuple{AG}, Tuple{AG}} where AG&lt;:AbstractGraph"><code>Base.reverse</code></a></li><li><a href="#Base.union-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>Base.union</code></a></li><li><a href="#LightGraphs.cartesian_product-Union{Tuple{G}, Tuple{G,G}} where G&lt;:AbstractGraph"><code>LightGraphs.cartesian_product</code></a></li><li><a href="#LightGraphs.complement"><code>LightGraphs.complement</code></a></li><li><a href="#LightGraphs.crosspath"><code>LightGraphs.crosspath</code></a></li><li><a href="#LightGraphs.difference-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>LightGraphs.difference</code></a></li><li><a href="#LightGraphs.egonet-Union{Tuple{U}, Tuple{T}, Tuple{AbstractGraph{T},Integer,Integer,AbstractArray{U,2}}} where U&lt;:Real where T&lt;:Integer"><code>LightGraphs.egonet</code></a></li><li><a href="#LightGraphs.induced_subgraph-Union{Tuple{U}, Tuple{AG}, Tuple{AG,AbstractArray{U,1}}} where U&lt;:Integer where AG&lt;:AbstractGraph"><code>LightGraphs.induced_subgraph</code></a></li><li><a href="#LightGraphs.merge_vertices"><code>LightGraphs.merge_vertices</code></a></li><li><a href="#LightGraphs.merge_vertices!"><code>LightGraphs.merge_vertices!</code></a></li><li><a href="#LightGraphs.symmetric_difference-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>LightGraphs.symmetric_difference</code></a></li><li><a href="#LightGraphs.tensor_product-Union{Tuple{G}, Tuple{G,G}} where G&lt;:AbstractGraph"><code>LightGraphs.tensor_product</code></a></li><li><a href="#SparseArrays.blockdiag-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>SparseArrays.blockdiag</code></a></li></ul><h2 id="Full-Docs-1"><a class="docs-heading-anchor" href="#Full-Docs-1">Full Docs</a><a class="docs-heading-anchor-permalink" href="#Full-Docs-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.intersect-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph" href="#Base.intersect-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersect(g, h)</code></pre><p>Return a graph with edges that are only in both graph <code>g</code> and graph <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>This function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Unless overriden, edge metadata, if present and supported, is only preserved for the graph with the smaller number of edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; foreach(println, edges(intersect(g1, g2)))
Edge 1 =&gt; 2
Edge 2 =&gt; 3
Edge 3 =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L131-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.join-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph" href="#Base.join-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>Base.join</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">join(g, h)</code></pre><p>Return a graph that combines graphs <code>g</code> and <code>h</code> using <code>blockdiag</code> and then adds all the edges between the vertices in <code>g</code> and those in <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata from <code>h</code> (if the graph supports it).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = join(star_graph(3), path_graph(2))
{5, 9} undirected simple Int64 graph

julia&gt; collect(edges(g))
9-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 1 =&gt; 4
 Edge 1 =&gt; 5
 Edge 2 =&gt; 4
 Edge 2 =&gt; 5
 Edge 3 =&gt; 4
 Edge 3 =&gt; 5
 Edge 4 =&gt; 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L250-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Union{Tuple{AG}, Tuple{AG}} where AG&lt;:AbstractGraph" href="#Base.reverse-Union{Tuple{AG}, Tuple{AG}} where AG&lt;:AbstractGraph"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reverse(g)</code></pre><p>Return a directed graph where all edges are reversed from the original directed graph.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; foreach(println, edges(reverse(g)))
Edge 1 =&gt; 3
Edge 2 =&gt; 1
Edge 3 =&gt; 2
Edge 4 =&gt; 3
Edge 4 =&gt; 5
Edge 5 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L56-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph" href="#Base.union-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">union(g, h)</code></pre><p>Return a graph that combines graphs <code>g</code> and <code>h</code> by taking the set union of all vertices and edges.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Where edges exist in both graphs, the edges from the larger graph are kept.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(3); h = SimpleGraph(5);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 1, 3);

julia&gt; add_edge!(h, 3, 4);

julia&gt; add_edge!(h, 3, 5);

julia&gt; add_edge!(h, 4, 5);

julia&gt; f = union(g, h);

julia&gt; collect(edges(f))
5-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 3 =&gt; 4
 Edge 3 =&gt; 5
 Edge 4 =&gt; 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L338-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.cartesian_product-Union{Tuple{G}, Tuple{G,G}} where G&lt;:AbstractGraph" href="#LightGraphs.cartesian_product-Union{Tuple{G}, Tuple{G,G}} where G&lt;:AbstractGraph"><code>LightGraphs.cartesian_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesian_product(g, h)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Cartesian_product_of_graphs">cartesian product</a> of <code>g</code> and <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata (if the graph supports it).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = cartesian_product(star_graph(3), path_graph(3))
{9, 12} undirected simple Int64 graph

julia&gt; collect(edges(g))
12-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 4
 Edge 1 =&gt; 7
 Edge 2 =&gt; 3
 Edge 2 =&gt; 5
 Edge 2 =&gt; 8
 Edge 3 =&gt; 6
 Edge 3 =&gt; 9
 Edge 4 =&gt; 5
 Edge 5 =&gt; 6
 Edge 7 =&gt; 8
 Edge 8 =&gt; 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L495-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.complement" href="#LightGraphs.complement"><code>LightGraphs.complement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">complement(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Complement_graph">graph complement</a> of a graph.</p><p><strong>Implementation Notes</strong></p><p>Preserves the <code>eltype</code> of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; foreach(println, edges(complement(g)))
Edge 1 =&gt; 3
Edge 1 =&gt; 4
Edge 1 =&gt; 5
Edge 2 =&gt; 1
Edge 2 =&gt; 4
Edge 2 =&gt; 5
Edge 3 =&gt; 2
Edge 3 =&gt; 5
Edge 4 =&gt; 1
Edge 4 =&gt; 2
Edge 4 =&gt; 3
Edge 5 =&gt; 1
Edge 5 =&gt; 2
Edge 5 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.crosspath" href="#LightGraphs.crosspath"><code>LightGraphs.crosspath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crosspath(len::Integer, g::Graph)</code></pre><p>Return a <a href="@ref">SimpleGraph</a> that duplicates <code>g</code> <code>len</code> times and connects each vertex with its copies in a path.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata (if the graph supports it).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = crosspath(3, path_graph(3))
{9, 12} undirected simple Int64 graph

julia&gt; collect(edges(g))
12-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 4
 Edge 2 =&gt; 3
 Edge 2 =&gt; 5
 Edge 3 =&gt; 6
 Edge 4 =&gt; 5
 Edge 4 =&gt; 7
 Edge 5 =&gt; 6
 Edge 5 =&gt; 8
 Edge 6 =&gt; 9
 Edge 7 =&gt; 8
 Edge 8 =&gt; 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L293-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.difference-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph" href="#LightGraphs.difference-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>LightGraphs.difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">difference(g, h)</code></pre><p>Return a graph with edges in graph <code>g</code> that are not in graph <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>Note that this function may produce a graph with 0-degree vertices. Preserves the <code>eltype</code> of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; foreach(println, edges(difference(g1, g2)))
Edge 3 =&gt; 4
Edge 4 =&gt; 5
Edge 5 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L169-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.egonet-Union{Tuple{U}, Tuple{T}, Tuple{AbstractGraph{T},Integer,Integer,AbstractArray{U,2}}} where U&lt;:Real where T&lt;:Integer" href="#LightGraphs.egonet-Union{Tuple{U}, Tuple{T}, Tuple{AbstractGraph{T},Integer,Integer,AbstractArray{U,2}}} where U&lt;:Real where T&lt;:Integer"><code>LightGraphs.egonet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">egonet(g, v, d)
egonet(g, v, d, distmx)</code></pre><p>Return the subgraph of <code>g</code> induced by the neighbors of <code>v</code> up to distance <code>d</code>, using weights (optionally) provided by <code>distmx</code>. This is equivalent to <a href="#LightGraphs.induced_subgraph-Union{Tuple{U}, Tuple{AG}, Tuple{AG,AbstractArray{U,1}}} where U&lt;:Integer where AG&lt;:AbstractGraph"><code>induced_subgraph</code></a><code>(g, neighborhood(g, v, d, dir=dir))[1].</code></p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: if <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> (i.e. <code>:in</code> or <code>:out</code>).</p><p><strong>Implementation Notes</strong></p><p>Unless overridden, this function does not preserve any metadata (if the graph supports it).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L697-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.induced_subgraph-Union{Tuple{U}, Tuple{AG}, Tuple{AG,AbstractArray{U,1}}} where U&lt;:Integer where AG&lt;:AbstractGraph" href="#LightGraphs.induced_subgraph-Union{Tuple{U}, Tuple{AG}, Tuple{AG,AbstractArray{U,1}}} where U&lt;:Integer where AG&lt;:AbstractGraph"><code>LightGraphs.induced_subgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">induced_subgraph(g, vlist)
induced_subgraph(g, elist)</code></pre><p>Return the subgraph of <code>g</code> induced by the vertices in  <code>vlist</code> or edges in <code>elist</code> along with a vector mapping the new vertices to the old ones (the  vertex <code>i</code> in the subgraph corresponds to the vertex <code>vmap[i]</code> in <code>g</code>.)</p><p>The returned graph has <code>length(vlist)</code> vertices, with the new vertex <code>i</code> corresponding to the vertex of the original graph in the <code>i</code>-th position of <code>vlist</code>.</p><p><strong>Implementation Notes</strong></p><p>Unless overridden, this function does not preserve any metadata (if the graph supports it).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = complete_graph(10)

julia&gt; sg, vmap = induced_subgraph(g, 5:8)

julia&gt; @assert g[5:8] == sg

julia&gt; @assert nv(sg) == 4

julia&gt; @assert ne(sg) == 6

julia&gt; @assert vm[4] == 8

julia&gt; sg, vmap = induced_subgraph(g, [2,8,3,4])

julia&gt; @assert sg == g[[2,8,3,4]]

julia&gt; elist = [Edge(1,2), Edge(3,4), Edge(4,8)]

julia&gt; sg, vmap = induced_subgraph(g, elist)

julia&gt; @assert sg == g[elist]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L600-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.merge_vertices" href="#LightGraphs.merge_vertices"><code>LightGraphs.merge_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">merge_vertices(g::AbstractGraph, vs)</code></pre><p>Create a new graph where all vertices in <code>vs</code> have been aliased to the same vertex <code>minimum(vs)</code>.</p><p><strong>Implementation Notes</strong></p><p>Unless overridden, this function does not preserve any metadata (if the graph supports it).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = path_graph(5);

julia&gt; collect(edges(g))
4-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3
 Edge 3 =&gt; 4
 Edge 4 =&gt; 5

julia&gt; h = merge_vertices(g, [2, 3]);

julia&gt; collect(edges(h))
3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3
 Edge 3 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L730-L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.merge_vertices!" href="#LightGraphs.merge_vertices!"><code>LightGraphs.merge_vertices!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">merge_vertices!(g, vs)</code></pre><p>Combine vertices specified in <code>vs</code> into single vertex whose index will be the lowest value in <code>vs</code>. All edges connected to vertices in <code>vs</code> connect to the new merged vertex.</p><p>Return a vector with new vertex values are indexed by the original vertex indices.</p><p><strong>Implementation Notes</strong></p><p>Unless overridden, this function does not preserve any metadata (if the graph supports it).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = path_graph(5);

julia&gt; collect(edges(g))
4-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3
 Edge 3 =&gt; 4
 Edge 4 =&gt; 5

julia&gt; merge_vertices!(g, [2, 3])
5-element Array{Int64,1}:
 1
 2
 2
 3
 4

julia&gt; collect(edges(g))
3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3
 Edge 3 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L810-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.symmetric_difference-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph" href="#LightGraphs.symmetric_difference-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>LightGraphs.symmetric_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symmetric_difference(g, h)</code></pre><p>Return a graph based on <code>g</code> with edges from graph <code>g</code> that do not exist in graph <code>h</code>, and vice versa.</p><p><strong>Implementation Notes</strong></p><p>Note that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = SimpleGraph(3); h = SimpleGraph(3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(h, 1, 3);

julia&gt; add_edge!(h, 2, 3);

julia&gt; f = symmetric_difference(g, h);

julia&gt; collect(edges(f))
3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 2 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L203-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.tensor_product-Union{Tuple{G}, Tuple{G,G}} where G&lt;:AbstractGraph" href="#LightGraphs.tensor_product-Union{Tuple{G}, Tuple{G,G}} where G&lt;:AbstractGraph"><code>LightGraphs.tensor_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensor_product(g, h)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Tensor_product_of_graphs">tensor product</a> of <code>g</code> and <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata (if the graph supports it).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using LightGraphs

julia&gt; g = tensor_product(star_graph(3), path_graph(3))
{9, 8} undirected simple Int64 graph

julia&gt; collect(edges(g))
8-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 5
 Edge 1 =&gt; 8
 Edge 2 =&gt; 4
 Edge 2 =&gt; 6
 Edge 2 =&gt; 7
 Edge 2 =&gt; 9
 Edge 3 =&gt; 5
 Edge 3 =&gt; 8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L549-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.blockdiag-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph" href="#SparseArrays.blockdiag-Union{Tuple{AG}, Tuple{AG,AG}} where AG&lt;:AbstractGraph"><code>SparseArrays.blockdiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blockdiag(g, h)</code></pre><p>Return a graph with <span>$|V(g)| + |V(h)|$</span> vertices and <span>$|E(g)| + |E(h)|$</span> edges where the vertices and edges from graph <code>h</code> are appended to graph <code>g</code>.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the <code>eltype</code>. Unless overridden, this function does not preserve any metadata from <code>h</code> (if the graph supports it).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; blockdiag(g1, g2)
{8, 9} directed simple Int64 graph

julia&gt; foreach(println, edges(blockdiag(g1, g2)))
Edge 1 =&gt; 2
Edge 2 =&gt; 3
Edge 3 =&gt; 1
Edge 3 =&gt; 4
Edge 4 =&gt; 5
Edge 5 =&gt; 4
Edge 6 =&gt; 7
Edge 7 =&gt; 8
Edge 8 =&gt; 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/9afa171f04ad94bb45b0400e803da064e04892bf/src/operators.jl#L86-L118">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../persistence/">« Reading / Writing Graphs</a><a class="docs-footer-nextpage" href="../plotting/">Plotting Graphs »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 16 July 2020 15:59">Thursday 16 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
