var documenterSearchIndex = {"docs":
[{"location":"persistence/#Reading-and-writing-Graphs-1","page":"Reading / Writing Graphs","title":"Reading and writing Graphs","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Pages   = [\"persistence.md\"]","category":"page"},{"location":"persistence/#Saving-using-*LightGraphs.jl*-lg-format.-1","page":"Reading / Writing Graphs","title":"Saving using LightGraphs.jl lg format.","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Graphs may be written to I/O streams and files using the savegraph function and read with the loadgraph function. The default graph format is a bespoke compressed LightGraphs.jl format LG.","category":"page"},{"location":"persistence/#Example-1","page":"Reading / Writing Graphs","title":"Example","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"\ng = erdos_renyi(5, 0.2)\n\nsavegraph(\"mygraph.lgz\", g)\nreloaded_g = loadgraph(\"mygraph.lgz\")","category":"page"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"In addition, graphs can also be saved in an uncompressed format using the compress=false option.","category":"page"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"\nsavegraph(\"mygraph.lg\", g, compress=false)\n\nreloaded_g = loadgraph(\"mygraph.lg\")","category":"page"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Finally, dictionaries of graphs can also be saved and subsequently re-loaded one by one.","category":"page"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"graph_dict = Dict(\"g1\" => erdos_renyi(5, 0.1),\n                  \"g2\" => erdos_renyi(10, 0.2),\n                  \"g3\" => erdos_renyi(2, 0.9))\n\nsavegraph(\"mygraph_dict.lg\", graph_dict)\n\n# Re-load only graph g1\nreloaded_g1 = loadgraph(\"mygraph_dict.lg\", \"g1\")","category":"page"},{"location":"persistence/#Full-docs-1","page":"Reading / Writing Graphs","title":"Full docs","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Modules = [LightGraphs]\nPages   = [\"persistence/common.jl\"]\nPrivate = false","category":"page"},{"location":"persistence/#Reading-and-Writing-using-other-formats-using-GraphIO-1","page":"Reading / Writing Graphs","title":"Reading and Writing using other formats using GraphIO","text":"","category":"section"},{"location":"persistence/#","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"The GraphIO.jl library provides tools for importing and exporting graph objects using common file types like edgelists, GraphML, Pajek NET, and more.","category":"page"},{"location":"linalg/#Linear-Algebra-1","page":"Linear Algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"LightGraphs.jl provides the following matrix operations on both directed and undirected graphs in the LinAlg submodule:","category":"page"},{"location":"linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"Order = [:type, :function]\nPages   = [\"linalg.md\"]","category":"page"},{"location":"linalg/#Full-Docs-1","page":"Linear Algebra","title":"Full Docs","text":"","category":"section"},{"location":"linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"Modules = [LightGraphs.LinAlg]\nPages   = [\n    \"graphmatrices.jl\",\n    \"Nonbacktracking.jl\",\n    \"spectral.jl\"\n]\nPrivate = false","category":"page"},{"location":"linalg/#LightGraphs.LinAlg","page":"Linear Algebra","title":"LightGraphs.LinAlg","text":"LinAlg\n\nA package for using the type system to check types of graph matrices.\n\n\n\n\n\n","category":"module"},{"location":"linalg/#LightGraphs.LinAlg.Adjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.Adjacency","text":"Adjacency{T}\n\nThe core Adjacency matrix structure. Keeps the vertex degrees around. Subtypes are used to represent the different normalizations of the adjacency matrix. Laplacian and its subtypes are used for the different Laplacian matrices.\n\nAdjacency(lapl::Laplacian) provides a generic function for getting the adjacency matrix of a Laplacian matrix. If your subtype of Laplacian does not provide a field A for the Adjacency instance, then attach another method to this function to provide an Adjacency{T} representation of the Laplacian. The Adjacency matrix here is the final subtype that corresponds to this type of Laplacian.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.AveragingAdjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.AveragingAdjacency","text":"AveragingAdjacency{T}\n\nThe matrix whose action is to average over each neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.AveragingLaplacian","page":"Linear Algebra","title":"LightGraphs.LinAlg.AveragingLaplacian","text":"AveragingLaplacian{T}\n\nLaplacian version of the AveragingAdjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.CombinatorialAdjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.CombinatorialAdjacency","text":"CombinatorialAdjacency{T,S,V}\n\nThe standard adjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.GraphMatrix","page":"Linear Algebra","title":"LightGraphs.LinAlg.GraphMatrix","text":"GraphMatrix{T}\n\nAn abstract type to allow opertions on any type of graph matrix\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.Noop","page":"Linear Algebra","title":"LightGraphs.LinAlg.Noop","text":"Noop\n\nA type that represents no action.\n\nImplementation Notes\n\nThe purpose of Noop is to help write more general code for the different scaled GraphMatrix types.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.NormalizedAdjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.NormalizedAdjacency","text":"NormalizedAdjacency{T}\n\nThe normalized adjacency matrix is hatA = D^-12 A D^-12. If A is symmetric, then the normalized adjacency is also symmetric with real eigenvalues bounded by [-1, 1].\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.NormalizedLaplacian","page":"Linear Algebra","title":"LightGraphs.LinAlg.NormalizedLaplacian","text":"NormalizedLaplacian{T}\n\nThe normalized Laplacian is hatL = I - D^-12 A D^-12. If A is symmetric, then the normalized Laplacian is also symmetric with positive eigenvalues bounded by 2.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.StochasticAdjacency","page":"Linear Algebra","title":"LightGraphs.LinAlg.StochasticAdjacency","text":"StochasticAdjacency{T}\n\nA transition matrix for the random walk.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.StochasticLaplacian","page":"Linear Algebra","title":"LightGraphs.LinAlg.StochasticLaplacian","text":"StochasticLaplacian{T}\n\nLaplacian version of the StochasticAdjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"linalg/#LightGraphs.LinAlg.degrees-Tuple{LightGraphs.LinAlg.CombinatorialAdjacency}","page":"Linear Algebra","title":"LightGraphs.LinAlg.degrees","text":"degrees(adjmat)\n\nReturn the degrees of a graph represented by the CombinatorialAdjacency adjmat.\n\n\n\n\n\n","category":"method"},{"location":"linalg/#LightGraphs.LinAlg.degrees-Tuple{LightGraphs.LinAlg.GraphMatrix}","page":"Linear Algebra","title":"LightGraphs.LinAlg.degrees","text":"degrees(graphmx)\n\nReturn the degrees of a graph represented by the graph matrix graphmx.\n\n\n\n\n\n","category":"method"},{"location":"linalg/#LightGraphs.LinAlg.symmetrize","page":"Linear Algebra","title":"LightGraphs.LinAlg.symmetrize","text":"symmetrize(A::SparseMatrix, which=:or)\n\nReturn a symmetric version of graph (represented by sparse matrix A) as a sparse matrix. which may be one of :triu, :tril, :sum, or :or. Use :sum for weighted graphs.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.symmetrize","page":"Linear Algebra","title":"LightGraphs.LinAlg.symmetrize","text":"symmetrize(adjmat, which=:or)\n\nReturn a symmetric version of graph (represented by CombinatorialAdjacency adjmat) as a CombinatorialAdjacency. which may be one of :triu, :tril, :sum, or :or. Use :sum for weighted graphs.\n\nImplementation Notes\n\nOnly works on Adjacency because the normalizations don't commute with symmetrization.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.adjacency_matrix","page":"Linear Algebra","title":"LightGraphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(g[, T=Int; dir=:out])\n\nReturn a sparse adjacency matrix for a graph, indexed by [u, v] vertices. Non-zero values indicate an edge from u to v. Users may override the default data type (Int) and specify an optional direction.\n\nOptional Arguments\n\ndir=:out: :in, :out, or :both are currently supported.\n\nImplementation Notes\n\nThis function is optimized for speed and directly manipulates CSC sparse matrix fields.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.adjacency_spectrum","page":"Linear Algebra","title":"LightGraphs.LinAlg.adjacency_spectrum","text":"adjacency_spectrum(g[, T=Int; dir=:unspec])\n\nReturn the eigenvalues of the adjacency matrix for a graph g, indexed by vertex. Default values for T are the same as those in adjacency_matrix.\n\nOptional Arguments\n\ndir=:unspec: Options for dir are the same as those in laplacian_matrix.\n\nPerformance\n\nConverts the matrix to dense with nv^2 memory usage.\n\nImplementation Notes\n\nUse eigs(adjacency_matrix(g);  kwargs...) to compute some of the eigenvalues/eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.incidence_matrix","page":"Linear Algebra","title":"LightGraphs.LinAlg.incidence_matrix","text":"incidence_matrix(g[, T=Int; oriented=false])\n\nReturn a sparse node-arc incidence matrix for a graph, indexed by [v, i], where i is in 1:ne(g), indexing an edge e. For directed graphs, a value of -1 indicates that src(e) == v, while a value of 1 indicates that dst(e) == v. Otherwise, the value is 0. For undirected graphs, both entries are 1 by default (this behavior can be overridden by the oriented optional argument).\n\nIf oriented (default false) is true, for an undirected graph g, the matrix will contain arbitrary non-zero values representing connectivity between v and i.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.laplacian_matrix-Union{Tuple{AbstractGraph{U}}, Tuple{U}, Tuple{AbstractGraph{U},DataType}} where U","page":"Linear Algebra","title":"LightGraphs.LinAlg.laplacian_matrix","text":"laplacian_matrix(g[, T=Int; dir=:unspec])\n\nReturn a sparse Laplacian matrix for a graph g, indexed by [u, v] vertices. T defaults to Int for both graph types.\n\nOptional Arguments\n\ndir=:unspec: :unspec, :both, :in, and:outare currently supported. For undirected graphs,dirdefaults to:out; for directed graphs,dirdefaults to:both`.\n\n\n\n\n\n","category":"method"},{"location":"linalg/#LightGraphs.LinAlg.laplacian_spectrum","page":"Linear Algebra","title":"LightGraphs.LinAlg.laplacian_spectrum","text":"laplacian_spectrum(g[, T=Int; dir=:unspec])\n\nReturn the eigenvalues of the Laplacian matrix for a graph g, indexed by vertex. Default values for T are the same as those in laplacian_matrix.\n\nOptional Arguments\n\ndir=:unspec: Options for dir are the same as those in laplacian_matrix.\n\nPerformance\n\nConverts the matrix to dense with nv^2 memory usage.\n\nImplementation Notes\n\nUse eigs(laplacian_matrix(g);  kwargs...) to compute some of the eigenvalues/eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#LightGraphs.LinAlg.spectral_distance","page":"Linear Algebra","title":"LightGraphs.LinAlg.spectral_distance","text":"spectral_distance(G₁, G₂ [, k])\n\nCompute the spectral distance between undirected n-vertex graphs G₁ and G₂ using the top k greatest eigenvalues. If k is ommitted, uses full spectrum.\n\nReferences\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\n\n\n\n","category":"function"},{"location":"distance/#Distance-1","page":"Distance","title":"Distance","text":"","category":"section"},{"location":"distance/#","page":"Distance","title":"Distance","text":"LightGraphs.jl includes the following distance measurements:","category":"page"},{"location":"distance/#","page":"Distance","title":"Distance","text":"Order = [:type, :function]\nPages   = [\"distance.md\"]","category":"page"},{"location":"distance/#Full-Docs-1","page":"Distance","title":"Full Docs","text":"","category":"section"},{"location":"distance/#","page":"Distance","title":"Distance","text":"Modules = [LightGraphs]\nPages   = [\n    \"distance.jl\",\n    \"transitivity.jl\"\n]\nPrivate = false","category":"page"},{"location":"contributing/#Contributor-Guide-1","page":"Contributing","title":"Contributor Guide","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"We welcome all possible contributors and ask that you read these guidelines before starting to work on this project. Following these guidelines will reduce friction and improve the speed at which your code gets merged.","category":"page"},{"location":"contributing/#Bug-reports-1","page":"Contributing","title":"Bug reports","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"If you notice code that crashes, is incorrect, or is too slow, please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the condition. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Please include version numbers of all relevant libraries and Julia itself.","category":"page"},{"location":"contributing/#A-note-on-licensing-1","page":"Contributing","title":"A note on licensing","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"LightGraphs.jl is licensed under the BSD Simplified 2-clause open source license. This means that we cannot accept any contributions that have been derived from GPL or other code with \"viral\" licenses incompatible with the BSD license. All code contributors must be able to attest that they have not made use of GPL code in any of their submissions, and contributors agree that their submissions are compatible with the BSD license.","category":"page"},{"location":"contributing/#Development-guidelines-1","page":"Contributing","title":"Development guidelines","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Correctness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.\nPRs should contain one logical enhancement to the codebase.\nSquash commits in a PR.\nOpen an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).\nMinimize dependencies on external packages, and avoid introducing new dependencies. In general,\nPRs introducing dependencies on Julia Base or the packages in the Julia Standard Library are ok.\nPRs introducing dependencies on third-party non-core \"leaf\" packages (no subdependencies except for Julia Base / Standard Library packages) are less ok.\nPRs introducing dependencies on third-party non-core non-leaf packages (that is, third-party packages that have dependencies on one or more other third-party packages) require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).\nPut type assertions on all function arguments where conflict may arise (use abstract types, Union, or Any if necessary).\nIf the algorithm was presented in a paper, include a reference to the paper (e.g., a proper academic citation along with an eprint link).\nTake steps to ensure that code works correctly and efficiently on disconnected graphs.\nWe can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.\nPrefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated (e.g., condition && error(\"message\") is good; condition && i += 1 is not).\nWrite code to reuse memory wherever possible. For example:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"function f(g, v)\n    storage = Vector{Int}(undef, nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"should be rewritten as two functions","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"function f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(undef, nv(g))\n    return f!(g, v, storage)\nend\n\nfunction f!(g::AbstractGraph, v::Integer, storage::AbstractVector{Int})\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"This gives users the option of reusing memory and improving performance.","category":"page"},{"location":"contributing/#Minimizing-use-of-internal-struct-fields-1","page":"Contributing","title":"Minimizing use of internal struct fields","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Since LightGraphs supports multiple implementations of the graph datastructure using the AbstractGraph type, you should refrain from using the internal fields of structs such as fadjlist. Instead, you should use the functions provided in the api. Code that is instrumental to defining a concrete graph type can use the internal structure of that type for example graph generators in /src/StaticGraphs/generators/staticgraphs.jl use the fadjlist field in order to construct graphs efficiently.","category":"page"},{"location":"contributing/#Git-usage-1","page":"Contributing","title":"Git usage","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"In order to make it easier for you to review Pull Requests (PRs), you can add this to your git config file, which should be located at $HOME/.julia/dev/LightGraphs/.git/config. Follow the instructions here.","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Locate the section for your github remote in the .git/config file. It looks like this:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"[remote \"origin\"]\n    fetch = +refs/heads/*:refs/remotes/origin/*\n    url = git@github.com:JuliaGraphs/LightGraphs.jl.git","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Now add the line fetch = +refs/pull/*/head:refs/remotes/origin/pr/* to this section. Obviously, change the github url to match your project's URL. It ends up looking like this:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"[remote \"origin\"]\n    fetch = +refs/heads/*:refs/remotes/origin/*\n    url = git@github.com:JuliaGraphs/LightGraphs.jl.git\n    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Now fetch all the pull requests:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"$ git fetch origin\nFrom github.com:JuliaGraphs/LightGraphs.jl\n * [new ref]         refs/pull/1000/head -> origin/pr/1000\n * [new ref]         refs/pull/1002/head -> origin/pr/1002\n * [new ref]         refs/pull/1004/head -> origin/pr/1004\n * [new ref]         refs/pull/1009/head -> origin/pr/1009\n...","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"To check out a particular pull request:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"$ git checkout pr/999\nBranch pr/999 set up to track remote branch pr/999 from origin.\nSwitched to a new branch 'pr/999'","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Now you can test a PR by running git fetch && git checkout pr/PRNUMBER && julia -e 'Pkg.test(\"LightGraphs\")'","category":"page"},{"location":"parallel/#Parallel-Graph-Algorithms-1","page":"Parallel Algorithms","title":"Parallel Graph Algorithms","text":"","category":"section"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"LightGraphs.Parallel is a module for graph algorithms that are parallelized. Their names should be consistent with the serial versions in the main module. In order to use parallel versions of the algorithms you can write:","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"using LightGraphs\nimport LightGraphs.Parallel\n\ng = path_graph(10)\nbc = Parallel.betweenness_centrality(g)","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"The arguments to parallel versions of functions match as closely as possible their serial versions  with potential addition default or keyword arguments to control parallel execution.  One exception is that for algorithms that cannot be meaningfully parallelized for  certain types of arguments a MethodError will be raised. For example, dijkstra_shortest_paths works for either a single or multiple source argument, but since the parallel version is slower when given only a single source, it will raise a MethodError.","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"g = Graph(10)\n# these work\nLightGraphs.dijkstra_shortest_paths(g,1)\nLightGraphs.dijkstra_shortest_paths(g, [1,2])\nParallel.dijkstra_shortest_paths(g, [1,2])\n# this doesn't\nParallel.dijkstra_shortest_paths(g,1)","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"Note that after importing or using LightGraphs.Parallel, you must fully qualify the version of the function you wish to use (using, e.g., LightGraphs.betweenness_centrality(g) for the sequential version and Parallel.betweenness_centrality(g) for the parallel version.)","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"The following is a current list of parallel algorithms:","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"Centrality measures:\nParallel.betweenness_centrality\nParallel.closeness_centrality\nParallel.pagerank\nParallel.radiality_centrality\nParallel.stress_centrality","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"Distance measures:\nParallel.center\nParallel.diameter\nParallel.eccentricity\nParallel.radius\nShortest paths algorithms:\nParallel.bellman_ford_shortest_paths\nParallel.dijkstra_shortest_paths\nParallel.floyd_warshall_shortest_paths\nParalell.johnson_shortest_paths\nTraversal algorithms:\nParallel.bfs\nParallel.greedy_color","category":"page"},{"location":"parallel/#","page":"Parallel Algorithms","title":"Parallel Algorithms","text":"Also note that in some cases, the arguments for the parallel versions may differ from the serial (standard) versions. As an example, parallel Dijkstra shortest paths takes advantage of multiple processors to execute centrality from multiple source vertices. It is an error to pass a single source vertex into the parallel version of dijkstrashortestpaths.","category":"page"},{"location":"pathing/#Path-and-Traversal-1","page":"Path and Traversal","title":"Path and Traversal","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs.jl provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by [src,dst] vertices. That is, distmx[2,4] = 2.5 assigns the distance 2.5 to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs distmx[4,2] has to be set.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Default edge distances may be passed in via the","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs.DefaultDistance","category":"page"},{"location":"pathing/#LightGraphs.DefaultDistance","page":"Path and Traversal","title":"LightGraphs.DefaultDistance","text":"DefaultDistance\n\nA matrix-like structure that provides distance values of 1 for any src, dst combination.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"structure.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"distance values for undefined edges will be ignored, and\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.","category":"page"},{"location":"pathing/#Graph-Traversal-1","page":"Path and Traversal","title":"Graph Traversal","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Graph traversal refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"BreadthFirst,\nDepthFirst, and\nMaximumAdjacency.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"bfs_tree\ndfs_tree\nmaximum_adjacency_visit\nbfs_parents\nhas_path\ndiffusion\ndiffusion_rate\nmincut","category":"page"},{"location":"pathing/#Random-walks-1","page":"Path and Traversal","title":"Random walks","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs includes uniform random walks and self avoiding walks:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"randomwalk\nnon_backtracking_randomwalk\nself_avoiding_walk","category":"page"},{"location":"pathing/#Connectivity-/-Bipartiteness-1","page":"Path and Traversal","title":"Connectivity / Bipartiteness","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"Graph connectivity functions are defined on both undirected and directed graphs:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"is_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nstrongly_connected_components_kosaraju\nweakly_connected_components\nhas_self_loops\nattracting_components\nis_bipartite\nbipartite_map\nbiconnected_components\ncondensation\nneighborhood\nneighborhood_dists\narticulation\nbridges\nperiod\nisgraphical","category":"page"},{"location":"pathing/#LightGraphs.has_self_loops","page":"Path and Traversal","title":"LightGraphs.has_self_loops","text":"has_self_loops(g)\n\nReturn true if g has any self loops.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> has_self_loops(g)\nfalse\n\njulia> add_edge!(g, 1, 1);\n\njulia> has_self_loops(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"pathing/#Cycle-Detection-1","page":"Path and Traversal","title":"Cycle Detection","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"In graph theory, a cycle is defined to be a path that starts from some vertex v and ends up at v.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"is_cyclic\nmaxsimplecycles\nsimplecycles\nsimplecycles_iter\nsimplecycles_hawick_james\nsimplecyclescount\nsimplecycleslength\nsimplecycles_limited_length\nkarp_minimum_cycle_mean","category":"page"},{"location":"pathing/#Minimum-Spanning-Trees-(MST)-Algorithms-1","page":"Path and Traversal","title":"Minimum Spanning Trees (MST) Algorithms","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"A Minimum Spanning Tree (MST) is a subset of the edges of a connected, edge-weighted (un)directed graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"kruskal_mst\nprim_mst","category":"page"},{"location":"pathing/#LightGraphs.kruskal_mst","page":"Path and Traversal","title":"LightGraphs.kruskal_mst","text":"kruskal_mst(g, distmx=weights(g); minimize=true)\n\nReturn a vector of edges representing the minimum (by default) spanning tree of a connected, undirected graph g with optional distance matrix distmx using Kruskal's algorithm.\n\nOptional Arguments\n\nminimize=true: if set to false, calculate the maximum spanning tree.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#LightGraphs.prim_mst","page":"Path and Traversal","title":"LightGraphs.prim_mst","text":"prim_mst(g, distmx=weights(g))\n\nReturn a vector of edges representing the minimum spanning tree of a connected, undirected graph g with optional distance matrix distmx using Prim's algorithm. Return a vector of edges.\n\n\n\n\n\n","category":"function"},{"location":"pathing/#Shortest-Path-Algorithms-1","page":"Path and Traversal","title":"Shortest-Path Algorithms","text":"","category":"section"},{"location":"pathing/#General-properties-of-shortest-path-algorithms-1","page":"Path and Traversal","title":"General properties of shortest path algorithms","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"The distance from a vertex to itself is always 0.\nThe distance between two vertices with no connecting edge is always Inf.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"a_star\ndijkstra_shortest_paths\ndesopo_pape_shortest_paths\nbellman_ford_shortest_paths\nfloyd_warshall_shortest_paths\nyen_k_shortest_paths\nspfa_shortest_paths","category":"page"},{"location":"pathing/#Path-discovery-/-enumeration-1","page":"Path and Traversal","title":"Path discovery / enumeration","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"gdistances\ngdistances!\nenumerate_paths","category":"page"},{"location":"pathing/#Path-States-1","page":"Path and Traversal","title":"Path States","text":"","category":"section"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"All path states derive from","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs.AbstractPathState","category":"page"},{"location":"pathing/#LightGraphs.AbstractPathState","page":"Path and Traversal","title":"LightGraphs.AbstractPathState","text":"AbstractPathState\n\nAn abstract type that provides information from shortest paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"The dijkstra_shortest_paths, floyd_warshall_shortest_paths, bellman_ford_shortest_paths, and yen_shortest_paths functions return states that contain various  information about the graph learned during traversal.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"LightGraphs.DijkstraState\nLightGraphs.DEsopoPapeState\nLightGraphs.BellmanFordState\nLightGraphs.FloydWarshallState\nLightGraphs.YenState","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"The above state types (with the exception of YenState) have the following common information, accessible via the type:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":".dists Holds a vector of distances computed, indexed by source vertex.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":".parents Holds a vector of parents of each vertex on the paths. The parent of a source vertex is always 0.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"(YenState substitutes .paths for .parents.)","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":"In addition, the following information may be populated with the appropriate arguments to dijkstra_shortest_paths:","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":".predecessors Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.","category":"page"},{"location":"pathing/#","page":"Path and Traversal","title":"Path and Traversal","text":".pathcounts Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the .predecessors output above.","category":"page"},{"location":"generators/#Making-and-Modifying-Graphs-1","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"LightGraphs.jl provides a number of methods for creating a graph object, including tools for building and modifying graph objects, a wide array of graph generator functions, and the ability to read and write graphs from files (using GraphIO.jl).","category":"page"},{"location":"generators/#Modifying-graphs-1","page":"Making and Modifying Graphs","title":"Modifying graphs","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"LightGraphs.jl offers a range of tools for modifying graphs, including:","category":"page"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"SimpleGraph\nSimpleGraphFromIterator\nSimpleDiGraph\nSimpleDiGraphFromIterator\nEdge\nadd_edge!\nrem_edge!\nadd_vertex!\nadd_vertices!\nrem_vertex!\nzero","category":"page"},{"location":"generators/#LightGraphs.add_edge!","page":"Making and Modifying Graphs","title":"LightGraphs.add_edge!","text":"add_edge!(g, e)\n\nAdd an edge e to graph g. Return true if edge was added successfully, otherwise return false.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2)\ntrue\n\njulia> add_edge!(g, 2, 3)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.rem_edge!","page":"Making and Modifying Graphs","title":"LightGraphs.rem_edge!","text":"rem_edge!(g, e)\n\nRemove an edge e from graph g. Return true if edge was removed successfully, otherwise return false.\n\nImplementation Notes\n\nIf rem_edge! returns false, the graph may be in an indeterminate state, as there are multiple points where the function can exit with false.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> rem_edge!(g, 1, 2)\ntrue\n\njulia> rem_edge!(g, 1, 2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.add_vertex!","page":"Making and Modifying Graphs","title":"LightGraphs.add_vertex!","text":"add_vertex!(g)\n\nAdd a new vertex to the graph g. Return true if addition was successful.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(Int8(typemax(Int8) - 1))\n{126, 0} undirected simple Int8 graph\n\njulia> add_vertex!(g)\ntrue\n\njulia> add_vertex!(g)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.add_vertices!","page":"Making and Modifying Graphs","title":"LightGraphs.add_vertices!","text":"add_vertices!(g, n)\n\nAdd n new vertices to the graph g. Return the number of vertices that were added successfully.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph()\n{0, 0} undirected simple Int64 graph\n\njulia> add_vertices!(g, 2)\n2\n\n\n\n\n\n","category":"function"},{"location":"generators/#LightGraphs.rem_vertex!","page":"Making and Modifying Graphs","title":"LightGraphs.rem_vertex!","text":"rem_vertex!(g, v)\n\nRemove the vertex v from graph g. Return false if removal fails (e.g., if vertex is not in the graph); true otherwise.\n\nPerformance\n\nTime complexity is mathcalO(k^2), where k is the max of the degrees of vertex v and vertex V.\n\nImplementation Notes\n\nThis operation has to be performed carefully if one keeps external data structures indexed by edges or vertices in the graph, since internally the removal is performed swapping the vertices v  and V, and removing the last vertex V from the graph. After removal the vertices in g will be indexed by 1V-1.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> rem_vertex!(g, 2)\ntrue\n\njulia> rem_vertex!(g, 2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"generators/#Base.zero","page":"Making and Modifying Graphs","title":"Base.zero","text":"zero(G)\n\nReturn a zero-vertex, zero-edge version of the graph type G. The fallback is defined for graph values zero(g::G) = zero(G).\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> zero(typeof(g))\n{0, 0} directed simple Int64 graph\n\njulia> zero(g)\n{0, 0} directed simple Int64 graph\n\n\n\n\n\n","category":"function"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"In addition to these core functions, more advanced operators can be found in Operators.","category":"page"},{"location":"generators/#Graph-Generators-1","page":"Making and Modifying Graphs","title":"Graph Generators","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"LightGraphs.jl implements numerous graph generators, including random graph generators, constructors for classic graphs, numerous small graphs with familiar topologies, and random and static graphs embedded in Euclidean space.","category":"page"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"Modules = [LightGraphs]\nPages   = [\"generators.md\"]","category":"page"},{"location":"generators/#Datasets-1","page":"Making and Modifying Graphs","title":"Datasets","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"Other notorious graphs and integration with the MatrixDepot.jl package are available in the Datasets submodule of the companion package LightGraphsExtras.jl. Selected graphs from the Stanford Large Network Dataset Collection may be found in the SNAPDatasets.jl package.","category":"page"},{"location":"generators/#All-Generators-1","page":"Making and Modifying Graphs","title":"All Generators","text":"","category":"section"},{"location":"generators/#","page":"Making and Modifying Graphs","title":"Making and Modifying Graphs","text":"Modules = [LightGraphs.SimpleGraphs]\nPages   = [\n    \"generators/randgraphs.jl\",\n    \"generators/staticgraphs.jl\",\n    \"generators/smallgraphs.jl\",\n    \"generators/euclideangraphs.jl\"]\nPrivate = false","category":"page"},{"location":"matching/#Matching-1","page":"Matching","title":"Matching","text":"","category":"section"},{"location":"matching/#","page":"Matching","title":"Matching","text":"Maximum weight matching is supported in the companion package LightGraphsMatching.jl.","category":"page"},{"location":"centrality/#Centrality-Measures-1","page":"Centrality Measures","title":"Centrality Measures","text":"","category":"section"},{"location":"centrality/#","page":"Centrality Measures","title":"Centrality Measures","text":"Centrality measures describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in LightGraphs.jl include the following:","category":"page"},{"location":"centrality/#","page":"Centrality Measures","title":"Centrality Measures","text":"Pages   = [\"centrality.md\"]","category":"page"},{"location":"centrality/#Full-docs-1","page":"Centrality Measures","title":"Full docs","text":"","category":"section"},{"location":"centrality/#","page":"Centrality Measures","title":"Centrality Measures","text":"Modules = [LightGraphs]\nPages   = [\n    \"centrality/betweenness.jl\",\n    \"centrality/closeness.jl\",\n    \"centrality/degree.jl\",\n    \"centrality/eigenvector.jl\",\n    \"centrality/katz.jl\",\n    \"centrality/pagerank.jl\",\n    \"centrality/stress.jl\",\n    \"centrality/radiality.jl\"\n]\nPrivate = false","category":"page"},{"location":"graphtypes/#Graph-Types-1","page":"Choosing A Graph Type","title":"Graph Types","text":"","category":"section"},{"location":"graphtypes/#","page":"Choosing A Graph Type","title":"Choosing A Graph Type","text":"In addition to providing SimpleGraph and SimpleDiGraph implementations, LightGraphs also serves as a framework for other graph types. Currently, there are several alternative graph types, each with its own package:","category":"page"},{"location":"graphtypes/#","page":"Choosing A Graph Type","title":"Choosing A Graph Type","text":"SimpleWeightedGraphs provides a structure for (un)directed graphs with the ability to specify weights on edges.\nMetaGraphs provides a structure (un)directed graphs that supports user-defined properties on the graph, vertices, and edges.\nStaticGraphs supports very large graph structures in a space- and time-efficient manner, but as the name implies, does not allow modification of the graph once created.","category":"page"},{"location":"graphtypes/#Which-Graph-Type-Should-I-Use?-1","page":"Choosing A Graph Type","title":"Which Graph Type Should I Use?","text":"","category":"section"},{"location":"graphtypes/#","page":"Choosing A Graph Type","title":"Choosing A Graph Type","text":"These are general guidelines to help you select the proper graph type.","category":"page"},{"location":"graphtypes/#","page":"Choosing A Graph Type","title":"Choosing A Graph Type","text":"In general, prefer the native SimpleGraphs/SimpleDiGraphs structures in LightGraphs.jl.\nIf you need edge weights and don't require large numbers of graph modifications, use SimpleWeightedGraphs.\nIf you need labeling of vertices or edges, use MetaGraphs.\nIf you work with very large graphs (billons to tens of billions of edges) and don't need mutability, use StaticGraphs.","category":"page"},{"location":"developing/#Developing-Alternate-Graph-Types-1","page":"Developer Notes","title":"Developing Alternate Graph Types","text":"","category":"section"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"This section is designed to guide developers who wish to write their own graph structures.","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"All LightGraphs functions rely on a standard API to function. As long as your graph structure is a subtype of AbstractGraph and implements the following API functions, all functions within the LightGraphs package should just work:","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"edges\nBase.eltype\nedgetype (example: edgetype(g::CustomGraph) = LightGraphs.SimpleEdge{eltype(g)}))\nhas_edge\ninneighbors\nne\nnv\noutneighbors\nzero\nis_directed: Note that since LightGraphs uses traits to determine directedness, is_directed for a CustomGraph type","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"must be implemented with the following signature:","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"is_directed(::Type{CustomGraph})::Bool (example: is_directed(::Type{<:CustomGraph}) = false)","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"The following signature is optional:","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"is_directed(g::CustomGraph)::Bool","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"If the graph structure is designed to represent weights on edges, the weights function should also be defined. Note that the output does not necessarily have to be a dense matrix, but it must be a subtype of AbstractMatrix{<:Real} and indexable via [u, v].","category":"page"},{"location":"developing/#Contiguous-vertices-1","page":"Developer Notes","title":"Contiguous vertices","text":"","category":"section"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"Some LightGraphs functions work under the assumption that the vertices are contiguous integers from one(eltype(g)) to nv(g). For graph types which do not respect this assumption, the method has_contiguous_vertices should be implemented and set to false. The following methods, which use this assumption when possible, should also be redefined:","category":"page"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"has_vertex\nvertices","category":"page"},{"location":"developing/#Inheriting-from-AbstractSimpleGraph-1","page":"Developer Notes","title":"Inheriting from AbstractSimpleGraph","text":"","category":"section"},{"location":"developing/#","page":"Developer Notes","title":"Developer Notes","text":"AbstractSimpleGraph is the supertype of both SimpleGraph and SimpleDiGraph. Every subtype of AbstractSimpleGraph must return neighbors in ascending order.","category":"page"},{"location":"core/#Core-Functions-1","page":"Core Functions","title":"Core Functions","text":"","category":"section"},{"location":"core/#","page":"Core Functions","title":"Core Functions","text":"LightGraphs.jl includes the following core functions:","category":"page"},{"location":"core/#","page":"Core Functions","title":"Core Functions","text":"Order = [:type, :function]\nPages   = [\"core.md\"]","category":"page"},{"location":"core/#Full-Docs-1","page":"Core Functions","title":"Full Docs","text":"","category":"section"},{"location":"core/#","page":"Core Functions","title":"Core Functions","text":"Modules = [LightGraphs]\nPages   = [ \"core.jl\"]\nPrivate = false","category":"page"},{"location":"core/#LightGraphs.all_neighbors","page":"Core Functions","title":"LightGraphs.all_neighbors","text":"all_neighbors(g, v)\n\nReturn a list of all inbound and outbound neighbors of v in g. For undirected graphs, this is equivalent to both outneighbors and inneighbors.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> all_neighbors(g, 1)\n1-element Array{Int64,1}:\n 3\n\njulia> all_neighbors(g, 2)\n1-element Array{Int64,1}:\n 3\n\njulia> all_neighbors(g, 3)\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"core/#LightGraphs.common_neighbors-Tuple{AbstractGraph,Integer,Integer}","page":"Core Functions","title":"LightGraphs.common_neighbors","text":"common_neighbors(g, u, v)\n\nReturn the neighbors common to vertices u and v in g.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(4);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> add_edge!(g, 4, 1);\n\njulia> add_edge!(g, 1, 3);\n\njulia> common_neighbors(g, 1, 3)\n2-element Array{Int64,1}:\n 2\n 4\n\njulia> common_neighbors(g, 1, 4)\n1-element Array{Int64,1}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.degree","page":"Core Functions","title":"LightGraphs.degree","text":"degree(g[, v])\n\nReturn a vector corresponding to the number of edges which start or end at each vertex in graph g. If v is specified, only return degrees for vertices in v. For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> degree(g)\n3-element Array{Int64,1}:\n 1\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"core/#LightGraphs.degree_histogram-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T},Any}} where T","page":"Core Functions","title":"LightGraphs.degree_histogram","text":"degree_histogram(g, degfn=degree)\n\nReturn a Dict with values representing the number of vertices that have degree represented by the key.\n\nDegree function (for example, indegree or outdegree) may be specified by overriding degfn.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.density","page":"Core Functions","title":"LightGraphs.density","text":"density(g)\n\nReturn the density of g. Density is defined as the ratio of the number of actual edges to the number of possible edges (V(V-1) for directed graphs and fracV(V-1)2 for undirected graphs).\n\n\n\n\n\n","category":"function"},{"location":"core/#LightGraphs.has_self_loops-Tuple{AbstractGraph}","page":"Core Functions","title":"LightGraphs.has_self_loops","text":"has_self_loops(g)\n\nReturn true if g has any self loops.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> has_self_loops(g)\nfalse\n\njulia> add_edge!(g, 1, 1);\n\njulia> has_self_loops(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.indegree-Tuple{AbstractGraph,Integer}","page":"Core Functions","title":"LightGraphs.indegree","text":"indegree(g[, v])\n\nReturn a vector corresponding to the number of edges which end at each vertex in graph g. If v is specified, only return degrees for vertices in v.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> indegree(g)\n3-element Array{Int64,1}:\n 1\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.is_ordered-Tuple{AbstractEdge}","page":"Core Functions","title":"LightGraphs.is_ordered","text":"is_ordered(e)\n\nReturn true if the source vertex of edge e is less than or equal to the destination vertex.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(2);\n\njulia> add_edge!(g, 2, 1);\n\njulia> is_ordered(first(edges(g)))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.neighbors-Tuple{AbstractGraph,Integer}","page":"Core Functions","title":"LightGraphs.neighbors","text":"neighbors(g, v)\n\nReturn a list of all neighbors reachable from vertex v in g. For directed graphs, the default is equivalent to outneighbors; use all_neighbors to list inbound and outbound neighbors.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> neighbors(g, 1)\n0-element Array{Int64,1}\n\njulia> neighbors(g, 2)\n1-element Array{Int64,1}:\n 3\n\njulia> neighbors(g, 3)\n1-element Array{Int64,1}:\n 1\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.num_self_loops-Tuple{AbstractGraph}","page":"Core Functions","title":"LightGraphs.num_self_loops","text":"num_self_loops(g)\n\nReturn the number of self loops in g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> num_self_loops(g)\n0\n\njulia> add_edge!(g, 1, 1);\n\njulia> num_self_loops(g)\n1\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.outdegree-Tuple{AbstractGraph,Integer}","page":"Core Functions","title":"LightGraphs.outdegree","text":"outdegree(g[, v])\n\nReturn a vector corresponding to the number of edges which start at each vertex in graph g. If v is specified, only return degrees for vertices in v.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = DiGraph(3);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> outdegree(g)\n3-element Array{Int64,1}:\n 0\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.weights-Tuple{AbstractGraph}","page":"Core Functions","title":"LightGraphs.weights","text":"weights(g)\n\nReturn the weights of the edges of a graph g as a matrix. Defaults to LightGraphs.DefaultDistance.\n\nImplementation Notes\n\nIn general, referencing the weight of a nonexistent edge is undefined behavior. Do not rely on the weights matrix as a substitute for the graph's adjacency_matrix.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.Δ-Tuple{Any}","page":"Core Functions","title":"LightGraphs.Δ","text":"Δ(g)\n\nReturn the maximum degree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.Δin-Tuple{Any}","page":"Core Functions","title":"LightGraphs.Δin","text":"Δin(g)\n\nReturn the maximum indegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.Δout-Tuple{Any}","page":"Core Functions","title":"LightGraphs.Δout","text":"Δout(g)\n\nReturn the maximum outdegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.δ-Tuple{Any}","page":"Core Functions","title":"LightGraphs.δ","text":"δ(g)\n\nReturn the minimum degree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.δin-Tuple{Any}","page":"Core Functions","title":"LightGraphs.δin","text":"δin(g)\n\nReturn the minimum indegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"core/#LightGraphs.δout-Tuple{Any}","page":"Core Functions","title":"LightGraphs.δout","text":"δout(g)\n\nReturn the minimum outdegree of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"degeneracy/#Graph-Decomposition-1","page":"Degeneracy","title":"Graph Decomposition","text":"","category":"section"},{"location":"degeneracy/#","page":"Degeneracy","title":"Degeneracy","text":"LightGraphs.jl provides the following graph degeneracy functions:","category":"page"},{"location":"degeneracy/#","page":"Degeneracy","title":"Degeneracy","text":"Order = [:type, :function]\nPages   = [\"degeneracy.md\"]","category":"page"},{"location":"degeneracy/#Full-Docs-1","page":"Degeneracy","title":"Full Docs","text":"","category":"section"},{"location":"degeneracy/#","page":"Degeneracy","title":"Degeneracy","text":"Modules = [LightGraphs]\nPages   = [\"degeneracy.jl\"]\nPrivate = false","category":"page"},{"location":"coloring/#Coloring-1","page":"Coloring","title":"Coloring","text":"","category":"section"},{"location":"coloring/#","page":"Coloring","title":"Coloring","text":"LightGraphs.jl defines a structure and basic interface for coloring algorithms. Since coloring is a hard problem in the general case, users can extend the behavior and define their own function taking a graph as input and returning the Coloring structure.","category":"page"},{"location":"coloring/#","page":"Coloring","title":"Coloring","text":"Order = [:type, :function]\nPages = [\"coloring.md\"]","category":"page"},{"location":"coloring/#","page":"Coloring","title":"Coloring","text":"Modules = [LightGraphs]\nPages   = [\n    \"traversals/greedy_color.jl\",\n]","category":"page"},{"location":"errorhandling/#Error-Handling-1","page":"-","title":"Error Handling","text":"","category":"section"},{"location":"errorhandling/#","page":"-","title":"-","text":"In an ideal world, all software would work perfectly all the time. However, in the real world software encounters errors due to the outside world, bad input, bugs, or programmer error.","category":"page"},{"location":"errorhandling/#Types-of-Errors-1","page":"-","title":"Types of Errors","text":"","category":"section"},{"location":"errorhandling/#Sentinel-Values-1","page":"-","title":"Sentinel Values","text":"","category":"section"},{"location":"errorhandling/#","page":"-","title":"-","text":"It is the position of this project that error conditions that happen often, typically due to bad data should be handled with sentinel values returned to indicate the failure condition. These are used for functions such as add_edge!(g, u, v). If you try to add an edge with negative vertex numbers, or vertices that exceed the number of vertices in the graph, then you will get a return value of false.","category":"page"},{"location":"errorhandling/#Errors-/-Exceptions-1","page":"-","title":"Errors / Exceptions","text":"","category":"section"},{"location":"errorhandling/#","page":"-","title":"-","text":"For more severe failures such as bad arguments or failure to converge, we use exceptions. The primary distinction between Sentinel Values and Argument Errors has to do with the run time of the function being called. In a function that is expected to be a called in a tight loop such as add_edge!, we will use a sentinel value rather than an exception. This is because it is faster to do a simple if statement to handle the error than a full try/catch block. For functions that take longer to run, we use Exceptions. If you find an exception with an error message that isn't helpful for debugging, please file a bug report so that we can improve these messages.","category":"page"},{"location":"errorhandling/#","page":"-","title":"-","text":"ArgumentError: the inputs to this function are not valid\nInexactError: there are types that cannot express something with the necessary precision","category":"page"},{"location":"basicproperties/#Accessing-Graph-Properties-1","page":"Accessing Properties","title":"Accessing Graph Properties","text":"","category":"section"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"The following is an overview of functions for accessing graph properties. For functions that modify graphs, see Making and Modifying Graphs.","category":"page"},{"location":"basicproperties/#Graph-Properties:-1","page":"Accessing Properties","title":"Graph Properties:","text":"","category":"section"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"nv: Returns number of vertices in graph.\nne: Returns number of edges in graph.\nvertices: Iterable object of all graph vertices.\nedges: Iterable object of all graph edges.\nhas_vertex: Checks for whether graph includes a vertex.\nhas_edge(g, s, d): Checks for whether graph includes an edge from a given source s to a given destination d.\nhas_edge(g, e) will return true if there is an edge in g that satisfies e == f for any f ∈ edges(g). This is a strict equality test that may require all properties of e are the same. This definition of equality depends on the implementation. For testing whether an edge exists between two vertices s,d use has_edge(g, s, d).","category":"page"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"Note: to use the has_edge(g, e) method safely, it is important to understand the conditions under which edges are equal to each other. These conditions are defined by the has_edge(g::G,e) method as defined by the graph type G. The default behavior is to check has_edge(g,src(e),dst(e)). This distinction exists to allow new graph types such as MetaGraphs or MultiGraphs to distinguish between edges with the same source and destination but potentially different properties.","category":"page"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"has_self_loops Checks for self-loops.\nis_directed Checks if graph is directed.\neltype Returns the element type of the graph.\nhas_contiguous_vertices Checks if contiguous vertices from one to nv(g) can be assumed for the graph type.","category":"page"},{"location":"basicproperties/#Vertex-Properties-1","page":"Accessing Properties","title":"Vertex Properties","text":"","category":"section"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"neighbors: Return array of neighbors of a vertex. If graph is directed, output is equivalent of outneighbors.\nall_neighbors:  Returns array of all neighbors (both inneighbors and outneighbors). For undirected graphs, equivalent to neighbors.\ninneighbors: Return array of in-neighbors. Equivalent to neighbors for undirected graphs.\noutneighbors: Return array of out-neighbors. Equivalent to neighbors for undirected graphs.","category":"page"},{"location":"basicproperties/#Edge-Properties-1","page":"Accessing Properties","title":"Edge Properties","text":"","category":"section"},{"location":"basicproperties/#","page":"Accessing Properties","title":"Accessing Properties","text":"src: Give source vertex of an edge.\ndst: Give destination vertex of an edge.\nreverse: Creates a new edge running in opposite direction of passed edge.","category":"page"},{"location":"community/#Community-Structures-1","page":"Community Structures","title":"Community Structures","text":"","category":"section"},{"location":"community/#","page":"Community Structures","title":"Community Structures","text":"LightGraphs.jl contains many algorithm to detect and analyze community structures in graphs. These include:","category":"page"},{"location":"community/#","page":"Community Structures","title":"Community Structures","text":"Order = [:type, :function]\nPages   = [\"community.md\"]","category":"page"},{"location":"community/#Full-Docs-1","page":"Community Structures","title":"Full Docs","text":"","category":"section"},{"location":"community/#","page":"Community Structures","title":"Community Structures","text":"Modules = [LightGraphs]\nPages   = [\n    \"community/cliques.jl\",\n    \"community/clustering.jl\",\n    \"community/core-periphery.jl\",\n    \"community/label_propagation.jl\",\n    \"community/modularity.jl\"\n]\nPrivate = false","category":"page"},{"location":"integration/#Integration-with-other-packages-1","page":"Integration with other packages","title":"Integration with other packages","text":"","category":"section"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"LightGraphs.jl's integration with other Julia packages is designed to be straightforward. Here are a few examples.","category":"page"},{"location":"integration/#[Graphs.jl](http://github.com/JuliaLang/Graphs.jl)-1","page":"Integration with other packages","title":"Graphs.jl","text":"","category":"section"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"Creating a Graphs.jl simple_graph is easy:","category":"page"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"julia> s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia> for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end","category":"page"},{"location":"integration/#[Metis.jl](https://github.com/JuliaSparse/Metis.jl)-1","page":"Integration with other packages","title":"Metis.jl","text":"","category":"section"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"The Metis graph partitioning package can interface with LightGraphs.jl:","category":"page"},{"location":"integration/#","page":"Integration with other packages","title":"Integration with other packages","text":"julia> using LightGraphs\n\njulia> g = SimpleGraph(100,1000)\n{100, 1000} undirected graph\n\njulia> partGraphKway(g, 6)  # 6 partitions","category":"page"},{"location":"experimental/#Experimental-Graph-Algorithms-1","page":"Experimental Functionality","title":"Experimental Graph Algorithms","text":"","category":"section"},{"location":"experimental/#","page":"Experimental Functionality","title":"Experimental Functionality","text":"LightGraphs.Experimental is a module for graph algorithms that are newer or less stable. We can adopt algorithms before we finalize an interface for using them or if we feel that full support cannot be provided to the current implementation. You can expect new developments to land here before they make it into the main module. This enables the development to keep advancing without being risk averse because of stability guarantees. You can think of this module as a 0.X semantic version space; it is a place where you can play around with new algorithms, perspectives, and interfaces without fear of breaking critical code.","category":"page"},{"location":"experimental/#A-Note-To-Users-1","page":"Experimental Functionality","title":"A Note To Users","text":"","category":"section"},{"location":"experimental/#","page":"Experimental Functionality","title":"Experimental Functionality","text":"Code in this module is unstable and subject to change. Do not use any code in this module in production environments without understanding the (large) risks involved. However, we welcome bug reports and issues via the normal channels..","category":"page"},{"location":"experimental/#Graph-Isomorphism-1","page":"Experimental Functionality","title":"Graph Isomorphism","text":"","category":"section"},{"location":"experimental/#","page":"Experimental Functionality","title":"Experimental Functionality","text":"Here is the documentation for graph isomorphism functions.","category":"page"},{"location":"experimental/#","page":"Experimental Functionality","title":"Experimental Functionality","text":"Modules = [LightGraphs]\nPages   = [\n    \"Experimental/isomorphism.jl\",\n]\nPrivate = false","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"The LightGraphs.jl package is licensed under the Simplified \"2-clause\" BSD License:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Copyright (c) 2015: Seth Bromberger and other contributors.Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"LightGraphs uses code derived from and/or inspired by the following packages:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"NetworkX:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Copyright (C) 2004-2012, NetworkX Developers Aric Hagberg <hagberg@lanl.gov> Dan Schult <dschult@colgate.edu> Pieter Swart <swart@lanl.gov> All rights reserved.Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above with the distribution.\nNeither the name of the NetworkX Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Graphs.jl:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Copyright (c) 2012: John Myles White and other contributors.","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"OpenStreetMapX.jl:","category":"page"},{"location":"license/#","page":"License Information","title":"License Information","text":"MIT LicensePermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"operators/#Operators-1","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/#","page":"Operators","title":"Operators","text":"LightGraphs.jl implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both SimpleGraph or both SimpleDiGraph).","category":"page"},{"location":"operators/#","page":"Operators","title":"Operators","text":"Order = [:type, :function]\nPages   = [\"operators.md\"]","category":"page"},{"location":"operators/#Full-Docs-1","page":"Operators","title":"Full Docs","text":"","category":"section"},{"location":"operators/#","page":"Operators","title":"Operators","text":"Modules = [LightGraphs]\nPages   = [\"operators.jl\"]\nPrivate = false","category":"page"},{"location":"operators/#Base.intersect-Union{Tuple{AG}, Tuple{AG,AG}} where AG<:AbstractGraph","page":"Operators","title":"Base.intersect","text":"intersect(g, h)\n\nReturn a graph with edges that are only in both graph g and graph h.\n\nImplementation Notes\n\nThis function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Unless overriden, edge metadata, if present and supported, is only preserved for the graph with the smaller number of edges.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> foreach(println, edges(intersect(g1, g2)))\nEdge 1 => 2\nEdge 2 => 3\nEdge 3 => 1\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.join-Union{Tuple{AG}, Tuple{AG,AG}} where AG<:AbstractGraph","page":"Operators","title":"Base.join","text":"join(g, h)\n\nReturn a graph that combines graphs g and h using blockdiag and then adds all the edges between the vertices in g and those in h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata from h (if the graph supports it).\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = join(star_graph(3), path_graph(2))\n{5, 9} undirected simple Int64 graph\n\njulia> collect(edges(g))\n9-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 1 => 4\n Edge 1 => 5\n Edge 2 => 4\n Edge 2 => 5\n Edge 3 => 4\n Edge 3 => 5\n Edge 4 => 5\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.reverse-Union{Tuple{AG}, Tuple{AG}} where AG<:AbstractGraph","page":"Operators","title":"Base.reverse","text":"reverse(g)\n\nReturn a directed graph where all edges are reversed from the original directed graph.\n\nImplementation Notes\n\nPreserves the eltype of the input graph.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> foreach(println, edges(reverse(g)))\nEdge 1 => 3\nEdge 2 => 1\nEdge 3 => 2\nEdge 4 => 3\nEdge 4 => 5\nEdge 5 => 4\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.union-Union{Tuple{AG}, Tuple{AG,AG}} where AG<:AbstractGraph","page":"Operators","title":"Base.union","text":"union(g, h)\n\nReturn a graph that combines graphs g and h by taking the set union of all vertices and edges.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Where edges exist in both graphs, the edges from the larger graph are kept.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(3); h = SimpleGraph(5);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(h, 3, 4);\n\njulia> add_edge!(h, 3, 5);\n\njulia> add_edge!(h, 4, 5);\n\njulia> f = union(g, h);\n\njulia> collect(edges(f))\n5-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 3 => 4\n Edge 3 => 5\n Edge 4 => 5\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.cartesian_product-Union{Tuple{G}, Tuple{G,G}} where G<:AbstractGraph","page":"Operators","title":"LightGraphs.cartesian_product","text":"cartesian_product(g, h)\n\nReturn the cartesian product of g and h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata (if the graph supports it).\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = cartesian_product(star_graph(3), path_graph(3))\n{9, 12} undirected simple Int64 graph\n\njulia> collect(edges(g))\n12-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 4\n Edge 1 => 7\n Edge 2 => 3\n Edge 2 => 5\n Edge 2 => 8\n Edge 3 => 6\n Edge 3 => 9\n Edge 4 => 5\n Edge 5 => 6\n Edge 7 => 8\n Edge 8 => 9\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.complement","page":"Operators","title":"LightGraphs.complement","text":"complement(g)\n\nReturn the graph complement of a graph.\n\nImplementation Notes\n\nPreserves the eltype of the input graph.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> foreach(println, edges(complement(g)))\nEdge 1 => 3\nEdge 1 => 4\nEdge 1 => 5\nEdge 2 => 1\nEdge 2 => 4\nEdge 2 => 5\nEdge 3 => 2\nEdge 3 => 5\nEdge 4 => 1\nEdge 4 => 2\nEdge 4 => 3\nEdge 5 => 1\nEdge 5 => 2\nEdge 5 => 3\n\n\n\n\n\n","category":"function"},{"location":"operators/#LightGraphs.crosspath","page":"Operators","title":"LightGraphs.crosspath","text":"crosspath(len::Integer, g::Graph)\n\nReturn a SimpleGraph that duplicates g len times and connects each vertex with its copies in a path.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata (if the graph supports it).\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = crosspath(3, path_graph(3))\n{9, 12} undirected simple Int64 graph\n\njulia> collect(edges(g))\n12-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 4\n Edge 2 => 3\n Edge 2 => 5\n Edge 3 => 6\n Edge 4 => 5\n Edge 4 => 7\n Edge 5 => 6\n Edge 5 => 8\n Edge 6 => 9\n Edge 7 => 8\n Edge 8 => 9\n\n\n\n\n\n","category":"function"},{"location":"operators/#LightGraphs.difference-Union{Tuple{AG}, Tuple{AG,AG}} where AG<:AbstractGraph","page":"Operators","title":"LightGraphs.difference","text":"difference(g, h)\n\nReturn a graph with edges in graph g that are not in graph h.\n\nImplementation Notes\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> foreach(println, edges(difference(g1, g2)))\nEdge 3 => 4\nEdge 4 => 5\nEdge 5 => 4\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.egonet-Union{Tuple{U}, Tuple{T}, Tuple{AbstractGraph{T},Integer,Integer,AbstractArray{U,2}}} where U<:Real where T<:Integer","page":"Operators","title":"LightGraphs.egonet","text":"egonet(g, v, d)\negonet(g, v, d, distmx)\n\nReturn the subgraph of g induced by the neighbors of v up to distance d, using weights (optionally) provided by distmx. This is equivalent to induced_subgraph(g, neighborhood(g, v, d, dir=dir))[1].\n\nOptional Arguments\n\ndir=:out: if g is directed, this argument specifies the edge direction\n\nwith respect to v (i.e. :in or :out).\n\nImplementation Notes\n\nUnless overridden, this function does not preserve any metadata (if the graph supports it).\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.induced_subgraph-Union{Tuple{U}, Tuple{AG}, Tuple{AG,AbstractArray{U,1}}} where U<:Integer where AG<:AbstractGraph","page":"Operators","title":"LightGraphs.induced_subgraph","text":"induced_subgraph(g, vlist)\ninduced_subgraph(g, elist)\n\nReturn the subgraph of g induced by the vertices in  vlist or edges in elist along with a vector mapping the new vertices to the old ones (the  vertex i in the subgraph corresponds to the vertex vmap[i] in g.)\n\nThe returned graph has length(vlist) vertices, with the new vertex i corresponding to the vertex of the original graph in the i-th position of vlist.\n\nImplementation Notes\n\nUnless overridden, this function does not preserve any metadata (if the graph supports it).\n\nExamples\n\njulia> g = complete_graph(10)\n\njulia> sg, vmap = induced_subgraph(g, 5:8)\n\njulia> @assert g[5:8] == sg\n\njulia> @assert nv(sg) == 4\n\njulia> @assert ne(sg) == 6\n\njulia> @assert vm[4] == 8\n\njulia> sg, vmap = induced_subgraph(g, [2,8,3,4])\n\njulia> @assert sg == g[[2,8,3,4]]\n\njulia> elist = [Edge(1,2), Edge(3,4), Edge(4,8)]\n\njulia> sg, vmap = induced_subgraph(g, elist)\n\njulia> @assert sg == g[elist]\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.merge_vertices","page":"Operators","title":"LightGraphs.merge_vertices","text":"merge_vertices(g::AbstractGraph, vs)\n\nCreate a new graph where all vertices in vs have been aliased to the same vertex minimum(vs).\n\nImplementation Notes\n\nUnless overridden, this function does not preserve any metadata (if the graph supports it).\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> collect(edges(g))\n4-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n Edge 4 => 5\n\njulia> h = merge_vertices(g, [2, 3]);\n\njulia> collect(edges(h))\n3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n\n\n\n\n\n","category":"function"},{"location":"operators/#LightGraphs.merge_vertices!","page":"Operators","title":"LightGraphs.merge_vertices!","text":"merge_vertices!(g, vs)\n\nCombine vertices specified in vs into single vertex whose index will be the lowest value in vs. All edges connected to vertices in vs connect to the new merged vertex.\n\nReturn a vector with new vertex values are indexed by the original vertex indices.\n\nImplementation Notes\n\nUnless overridden, this function does not preserve any metadata (if the graph supports it).\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(5);\n\njulia> collect(edges(g))\n4-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n Edge 4 => 5\n\njulia> merge_vertices!(g, [2, 3])\n5-element Array{Int64,1}:\n 1\n 2\n 2\n 3\n 4\n\njulia> collect(edges(g))\n3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 4\n\n\n\n\n\n","category":"function"},{"location":"operators/#LightGraphs.symmetric_difference-Union{Tuple{AG}, Tuple{AG,AG}} where AG<:AbstractGraph","page":"Operators","title":"LightGraphs.symmetric_difference","text":"symmetric_difference(g, h)\n\nReturn a graph based on g with edges from graph g that do not exist in graph h, and vice versa.\n\nImplementation Notes\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(3); h = SimpleGraph(3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(h, 1, 3);\n\njulia> add_edge!(h, 2, 3);\n\njulia> f = symmetric_difference(g, h);\n\njulia> collect(edges(f))\n3-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"operators/#LightGraphs.tensor_product-Union{Tuple{G}, Tuple{G,G}} where G<:AbstractGraph","page":"Operators","title":"LightGraphs.tensor_product","text":"tensor_product(g, h)\n\nReturn the tensor product of g and h.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata (if the graph supports it).\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = tensor_product(star_graph(3), path_graph(3))\n{9, 8} undirected simple Int64 graph\n\njulia> collect(edges(g))\n8-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 5\n Edge 1 => 8\n Edge 2 => 4\n Edge 2 => 6\n Edge 2 => 7\n Edge 2 => 9\n Edge 3 => 5\n Edge 3 => 8\n\n\n\n\n\n","category":"method"},{"location":"operators/#SparseArrays.blockdiag-Union{Tuple{AG}, Tuple{AG,AG}} where AG<:AbstractGraph","page":"Operators","title":"SparseArrays.blockdiag","text":"blockdiag(g, h)\n\nReturn a graph with V(g) + V(h) vertices and E(g) + E(h) edges where the vertices and edges from graph h are appended to graph g.\n\nImplementation Notes\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype. Unless overridden, this function does not preserve any metadata from h (if the graph supports it).\n\nExamples\n\njulia> g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> blockdiag(g1, g2)\n{8, 9} directed simple Int64 graph\n\njulia> foreach(println, edges(blockdiag(g1, g2)))\nEdge 1 => 2\nEdge 2 => 3\nEdge 3 => 1\nEdge 3 => 4\nEdge 4 => 5\nEdge 5 => 4\nEdge 6 => 7\nEdge 7 => 8\nEdge 8 => 6\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Plotting-Graphs-1","page":"Plotting Graphs","title":"Plotting Graphs","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"LightGraphs.jl integrates with several other Julia packages for plotting. Here are a few examples.","category":"page"},{"location":"plotting/#[TikzGraphs.jl](https://github.com/sisl/TikzGraphs.jl)-1","page":"Plotting Graphs","title":"TikzGraphs.jl","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"Another nice graph visualization package. (TikzPictures.jl required to render/save):","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"julia> g = wheel_graph(10); t = plot(g)\n\njulia> save(SVG(\"wheel10.svg\"), t)","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"producing a graph like this:","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"(Image: Wheel Graph)","category":"page"},{"location":"plotting/#[GraphPlot.jl](https://github.com/afternone/GraphPlot.jl)-1","page":"Plotting Graphs","title":"GraphPlot.jl","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"Another graph visualization package that is very simple to use. Compose.jl is required for most rendering functionality:","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"julia> using GraphPlot, Compose\n\njulia> g = wheel_graph(10)\n\njulia> draw(PNG(\"/tmp/wheel10.png\", 16cm, 16cm), gplot(g))","category":"page"},{"location":"plotting/#[NetworkViz.jl](https://github.com/abhijithanilkumar/NetworkViz.jl)-1","page":"Plotting Graphs","title":"NetworkViz.jl","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"NetworkViz.jl is tightly coupled with LightGraphs.jl. Graphs can be visualized in 2D as well as 3D using ThreeJS.jl and Escher.jl.","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets, \"widgets\")\n  push!(window.assets,(\"ThreeJS\",\"threejs\"))\n  g = complete_graph(10)\n  drawGraph(g)\nend","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"The above code produces the following output:","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"(Image: alt tag)","category":"page"},{"location":"plotting/#[GraphRecipes.jl](https://github.com/JuliaPlots/GraphRecipes.jl)-1","page":"Plotting Graphs","title":"GraphRecipes.jl","text":"","category":"section"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"GraphRecipes is a collection of recipes for visualizing graphs. Users specify a graph through an adjacency matrix, an adjacency list, or an AbstractGraph via LightGraphs.","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"julia> using GraphRecipes, Plots\njulia> using LightGraphs\n\njulia> g = wheel_graph(10)\njulia> graphplot(g, curves=false)","category":"page"},{"location":"plotting/#","page":"Plotting Graphs","title":"Plotting Graphs","text":"(Image: WheelGraph)","category":"page"},{"location":"#LightGraphs-1","page":"Getting Started","title":"LightGraphs","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The goal of LightGraphs.jl is to offer a performant platform for network and graph analysis in Julia. To this end, LightGraphs offers both (a) a set of simple, concrete graph implementations – SimpleGraph (for undirected graphs) and SimpleDiGraph (for directed graphs), and (b) an API for the development of more sophisticated graph implementations under the AbstractGraph type.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"As such, LightGraphs.jl is the central package of the JuliaGraphs ecosystem. Additional functionality like advanced IO and file formats, weighted graphs, property graphs, and optimization related functions can be found in the following packages:","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"LightGraphsExtras.jl: extra functions for graph analysis.\nMetaGraphs.jl: graphs with associated meta-data.\nSimpleWeightedGraphs.jl: weighted graphs.\nGraphIO.jl: tools for importing and exporting graph objects using common file types like edgelists, GraphML, Pajek NET, and more.\nGraphDataFrameBridge.jl: Tools for converting edgelists stored in DataFrames into graphs (MetaGraphs, MetaDiGraphs).","category":"page"},{"location":"#Basic-library-examples-1","page":"Getting Started","title":"Basic library examples","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The LightGraphs.jl libraries includes numerous convenience functions for generating functions detailed in Making and Modifying Graphs, such as path_graph, which makes a simple undirected path graph of a given length. Once created, these graphs can be easily interrogated and modified.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"julia> g = path_graph(6)\n\n# Number of vertices\njulia> nv(g)\n\n# Number of edges\njulia> ne(g)\n\n# Add an edge to make the path a loop\njulia> add_edge!(g, 1, 6)","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"For an overview of basic functions for interacting with graphs, check out Accessing Graph Properties and Making and Modifying Graphs. Detailed tutorials may be found in the JuliaGraphs Tutorial Notebooks repository.","category":"page"},{"location":"citing/#","page":"Citing LightGraphs","title":"Citing LightGraphs","text":"We encourage you to cite our work if you have used our libraries, tools or datasets. Starring the repository on GitHub is also appreciated.","category":"page"},{"location":"citing/#","page":"Citing LightGraphs","title":"Citing LightGraphs","text":"The latest citation information may be found in the CITATION.bib file within the LightGraphs repository.","category":"page"},{"location":"citing/#","page":"Citing LightGraphs","title":"Citing LightGraphs","text":"For previous versions, please reference the zenodo site.","category":"page"},{"location":"types/#LightGraphs-Types-1","page":"LightGraphs Types","title":"LightGraphs Types","text":"","category":"section"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"LightGraphs.jl supports both the AbstractGraph type and two concrete simple graph types – SimpleGraph for undirected graphs and SimpleDiGraph for directed graphs – that are subtypes of AbstractGraph.","category":"page"},{"location":"types/#Concrete-Types-1","page":"LightGraphs Types","title":"Concrete Types","text":"","category":"section"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"LightGraphs.jl provides two concrete graph types: SimpleGraph is an undirected graph, and SimpleDiGraph is its directed counterpart. Both of these types can be parameterized to specifying how vertices are identified (by default, SimpleGraph and SimpleDiGraph use the system default integer type, usually Int64).","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"A graph G is described by a set of vertices V and edges E: G = {V, E}. V is an integer range 1:n; E is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields Edge types containing (src<:Integer, dst<:Integer) values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Graphs are created using SimpleGraph() or SimpleDiGraph(); there are several options (see the tutorials for examples).","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Multiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will not raise an error. This event can be detected using the return value of add_edge!.","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Note that graphs in which the number of vertices equals or approaches the typemax of the underlying graph element (e.g., a SimpleGraph{UInt8} with 127 vertices) may encounter arithmetic overflow errors in some functions, which should be reported as bugs. To be safe, please ensure that your graph is sized with some spare capacity.","category":"page"},{"location":"types/#AbstractGraph-Type-1","page":"LightGraphs Types","title":"AbstractGraph Type","text":"","category":"section"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"LightGraphs.jl is structured around a few abstract types developers can base their types on. See Developing Alternate Graph Types for the minimal methods to implement.","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Order = [:type]\nPages   = [\"types.md\"]","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"To encourage experimentation and development within the JuliaGraphs ecosystem, LightGraphs.jl defines the AbstractGraph type, which is used by libraries like MetaGraphs.jl (for graphs with associated meta-data) and SimpleWeightedGraphs.jl (for weighted graphs). All types that are a subset of AbstractGraph must implement the following functions (most of which are described in more detail in Accessing Graph Properties and Making and Modifying Graphs):","category":"page"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Order = [:function]\nPages   = [\"types.md\"]","category":"page"},{"location":"types/#Full-Docs-for-AbstractGraph-types-and-functions-1","page":"LightGraphs Types","title":"Full Docs for AbstractGraph types and functions","text":"","category":"section"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"Modules = [LightGraphs]\nPages   = [\"interface.jl\"]\nPrivate = false","category":"page"},{"location":"types/#LightGraphs.AbstractEdge","page":"LightGraphs Types","title":"LightGraphs.AbstractEdge","text":"AbstractEdge\n\nAn abstract type representing a single edge between two vertices of a graph.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightGraphs.AbstractEdgeIter","page":"LightGraphs Types","title":"LightGraphs.AbstractEdgeIter","text":"AbstractEdgeIter\n\nAn abstract type representing an edge iterator.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightGraphs.AbstractGraph","page":"LightGraphs Types","title":"LightGraphs.AbstractGraph","text":"AbstractGraph\n\nAn abstract type representing a graph.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightGraphs.HasContiguousVertices","page":"LightGraphs Types","title":"LightGraphs.HasContiguousVertices","text":"HasContiguousVertices{G}\n\nA trait indicating whether the vertices of graphs of type G are always contiguous integers starting at 1.\n\n\n\n\n\n","category":"type"},{"location":"types/#Base.reverse-Tuple{AbstractEdge}","page":"LightGraphs Types","title":"Base.reverse","text":"reverse(e)\n\nCreate a new edge from e with source and destination vertices reversed.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleDiGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> reverse(first(edges(g)))\nEdge 2 => 1\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.dst-Tuple{AbstractEdge}","page":"LightGraphs Types","title":"LightGraphs.dst","text":"dst(e)\n\nReturn the destination vertex of edge e.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> dst(first(edges(g)))\n2\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.edges-Tuple{Any}","page":"LightGraphs Types","title":"LightGraphs.edges","text":"edges(g)\n\nReturn (an iterator to or collection of) the edges of a graph. For AbstractSimpleGraphs it returns a SimpleEdgeIter. The expressions e in edges(g) and e ∈ edges(ga) evaluate as calls to has_edge.\n\nImplementation Notes\n\nA returned iterator is valid for one pass over the edges, and is invalidated by changes to g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(3);\n\njulia> collect(edges(g))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.edgetype-Tuple{AbstractGraph}","page":"LightGraphs Types","title":"LightGraphs.edgetype","text":"edgetype(g)\n\nReturn the type of graph g's edge\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.has_contiguous_vertices-Union{Tuple{Type{G}}, Tuple{G}} where G<:AbstractGraph","page":"LightGraphs Types","title":"LightGraphs.has_contiguous_vertices","text":"has_contiguous_vertices(::Type{G}) -> Bool where {G <: AbstractGraph}\n\nMethod implemented by graph types to indicate whether their vertices are contiguous numbers. Defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.has_edge-Tuple{Any,Any,Any}","page":"LightGraphs Types","title":"LightGraphs.has_edge","text":"has_edge(g, s, d)\n\nReturn true if the graph g has an edge from node s to node d.\n\nAn optional has_edge(g, e) can be implemented to check if an edge belongs to a graph, including any data other than source and destination node.\n\ne ∈ edges(g) or e ∈ edges(g) evaluate as calls to has_edge, c.f. edges.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleDiGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> has_edge(g, 1, 2)\ntrue\n\njulia> has_edge(g, 2, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.has_vertex","page":"LightGraphs Types","title":"LightGraphs.has_vertex","text":"has_vertex(g, v)\n\nReturn true if v is a vertex of g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> has_vertex(SimpleGraph(2), 1)\ntrue\n\njulia> has_vertex(SimpleGraph(2), 3)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"types/#LightGraphs.inneighbors-Tuple{Any,Any}","page":"LightGraphs Types","title":"LightGraphs.inneighbors","text":"inneighbors(g, v)\n\nReturn a list of all neighbors connected to vertex v by an incoming edge.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> inneighbors(g, 4)\n2-element Array{Int64,1}:\n 3\n 5\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.is_directed-Union{Tuple{G}, Tuple{G}} where G","page":"LightGraphs Types","title":"LightGraphs.is_directed","text":"is_directed(G)\n\nReturn true if the graph type G is a directed graph; false otherwise. New graph types must implement is_directed(::Type{<:G}). The method can also be called with is_directed(g::G)\n\nExamples\n\njulia> using LightGraphs\n\njulia> is_directed(SimpleGraph(2))\nfalse\n\njulia> is_directed(SimpleGraph)\nfalse\n\njulia> is_directed(SimpleDiGraph(2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.ne-Tuple{AbstractGraph}","page":"LightGraphs Types","title":"LightGraphs.ne","text":"ne(g)\n\nReturn the number of edges in g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = path_graph(3);\n\njulia> ne(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.nv-Tuple{AbstractGraph}","page":"LightGraphs Types","title":"LightGraphs.nv","text":"nv(g)\n\nReturn the number of vertices in g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> nv(SimpleGraph(3))\n3\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.outneighbors-Tuple{Any,Any}","page":"LightGraphs Types","title":"LightGraphs.outneighbors","text":"outneighbors(g, v)\n\nReturn a list of all neighbors connected to vertex v by an outgoing edge.\n\nImplementation Notes\n\nReturns a reference to the current graph's internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> outneighbors(g, 4)\n1-element Array{Int64,1}:\n 5\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.src-Tuple{AbstractEdge}","page":"LightGraphs Types","title":"LightGraphs.src","text":"src(e)\n\nReturn the source vertex of edge e.\n\nExamples\n\njulia> using LightGraphs\n\njulia> g = SimpleGraph(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> src(first(edges(g)))\n1\n\n\n\n\n\n","category":"method"},{"location":"types/#LightGraphs.vertices","page":"LightGraphs Types","title":"LightGraphs.vertices","text":"vertices(g::AbstractGraph)\n\nReturn (an iterator to or collection of) the vertices of a graph.\n\nImplementation Notes\n\nA returned iterator is valid for one pass over the edges, and is invalidated by changes to g.\n\nExamples\n\njulia> using LightGraphs\n\njulia> collect(vertices(SimpleGraph(4)))\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"types/#","page":"LightGraphs Types","title":"LightGraphs Types","text":"zero(::Type{<:AbstractGraph})","category":"page"},{"location":"types/#Base.zero-Tuple{Type{#s1} where #s1<:AbstractGraph}","page":"LightGraphs Types","title":"Base.zero","text":"zero(G)\n\nReturn a zero-vertex, zero-edge version of the graph type G. The fallback is defined for graph values zero(g::G) = zero(G).\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> zero(typeof(g))\n{0, 0} directed simple Int64 graph\n\njulia> zero(g)\n{0, 0} directed simple Int64 graph\n\n\n\n\n\n","category":"method"}]
}
